import { useRef, useState, useEffect, createContext, createElement, useDebugValue, useCallback, useContext } from 'react';

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
const hasInitialValue = (atom) => "init" in atom;
const IS_EQUAL_PROMISE = Symbol();
const INTERRUPT_PROMISE = Symbol();
const isInterruptablePromise = (promise) => !!promise[INTERRUPT_PROMISE];
const createInterruptablePromise = (promise) => {
  let interrupt;
  const interruptablePromise = new Promise((resolve, reject) => {
    interrupt = resolve;
    promise.then(resolve, reject);
  });
  interruptablePromise[IS_EQUAL_PROMISE] = (p) => p === interruptablePromise || p === promise;
  interruptablePromise[INTERRUPT_PROMISE] = interrupt;
  return interruptablePromise;
};
const createState = (initialValues, stateListener) => {
  const state = {
    l: stateListener,
    v: 0,
    a: new WeakMap(),
    m: new WeakMap(),
    p: new Map()
  };
  if (initialValues) {
    for (const [atom, value] of initialValues) {
      const atomState = { v: value, r: 0, d: new Map() };
      if (typeof process === "object" && process.env.NODE_ENV !== "production") {
        Object.freeze(atomState);
        if (!hasInitialValue(atom)) {
          console.warn("Found initial value for derived atom which can cause unexpected behavior", atom);
        }
      }
      state.a.set(atom, atomState);
    }
  }
  return state;
};
const getAtomState = (state, atom) => state.a.get(atom);
const wipAtomState = (state, atom, dependencies) => {
  const atomState = getAtomState(state, atom);
  const nextAtomState = __spreadProps(__spreadValues({
    r: 0
  }, atomState), {
    d: dependencies ? new Map(Array.from(dependencies).map((a) => {
      var _a, _b;
      return [
        a,
        (_b = (_a = getAtomState(state, a)) == null ? void 0 : _a.r) != null ? _b : 0
      ];
    })) : (atomState == null ? void 0 : atomState.d) || new Map()
  });
  return [nextAtomState, (atomState == null ? void 0 : atomState.d) || new Map()];
};
const setAtomValue = (state, atom, value, dependencies, promise) => {
  var _a, _b;
  const [atomState, prevDependencies] = wipAtomState(state, atom, dependencies);
  if (promise && !((_a = atomState.p) == null ? void 0 : _a[IS_EQUAL_PROMISE](promise))) {
    return;
  }
  (_b = atomState.c) == null ? void 0 : _b.call(atomState);
  delete atomState.e;
  delete atomState.p;
  delete atomState.c;
  delete atomState.i;
  if (!("v" in atomState) || !Object.is(atomState.v, value)) {
    atomState.v = value;
    ++atomState.r;
  }
  commitAtomState(state, atom, atomState, dependencies && prevDependencies);
};
const setAtomReadError = (state, atom, error, dependencies, promise) => {
  var _a, _b;
  const [atomState, prevDependencies] = wipAtomState(state, atom, dependencies);
  if (promise && !((_a = atomState.p) == null ? void 0 : _a[IS_EQUAL_PROMISE](promise))) {
    return;
  }
  (_b = atomState.c) == null ? void 0 : _b.call(atomState);
  delete atomState.p;
  delete atomState.c;
  delete atomState.i;
  atomState.e = error;
  commitAtomState(state, atom, atomState, prevDependencies);
};
const setAtomReadPromise = (state, atom, promise, dependencies) => {
  var _a, _b;
  const [atomState, prevDependencies] = wipAtomState(state, atom, dependencies);
  if ((_a = atomState.p) == null ? void 0 : _a[IS_EQUAL_PROMISE](promise)) {
    return;
  }
  (_b = atomState.c) == null ? void 0 : _b.call(atomState);
  if (isInterruptablePromise(promise)) {
    atomState.p = promise;
    delete atomState.c;
  } else {
    const interruptablePromise = createInterruptablePromise(promise);
    atomState.p = interruptablePromise;
    atomState.c = interruptablePromise[INTERRUPT_PROMISE];
  }
  commitAtomState(state, atom, atomState, prevDependencies);
};
const setAtomInvalidated = (state, atom) => {
  const [atomState] = wipAtomState(state, atom);
  atomState.i = atomState.r;
  commitAtomState(state, atom, atomState);
};
const setAtomWritePromise = (state, atom, promise) => {
  const [atomState] = wipAtomState(state, atom);
  if (promise) {
    atomState.w = promise;
  } else {
    delete atomState.w;
  }
  commitAtomState(state, atom, atomState);
};
const scheduleReadAtomState = (state, atom, promise) => {
  promise.finally(() => {
    readAtomState(state, atom, true);
  });
};
const readAtomState = (state, atom, force) => {
  if (!force) {
    const atomState = getAtomState(state, atom);
    if (atomState) {
      atomState.d.forEach((_, a) => {
        if (a !== atom) {
          const aState = getAtomState(state, a);
          if (aState && !aState.e && !aState.p && aState.r === aState.i) {
            readAtomState(state, a, true);
          }
        }
      });
      if (Array.from(atomState.d.entries()).every(([a, r]) => {
        const aState = getAtomState(state, a);
        return aState && !aState.e && !aState.p && aState.r !== aState.i && aState.r === r;
      })) {
        return atomState;
      }
    }
  }
  let error;
  let promise;
  let value;
  const dependencies = new Set();
  try {
    const promiseOrValue = atom.read((a) => {
      dependencies.add(a);
      if (a !== atom) {
        const aState2 = readAtomState(state, a);
        if (aState2.e) {
          throw aState2.e;
        }
        if (aState2.p) {
          throw aState2.p;
        }
        return aState2.v;
      }
      const aState = getAtomState(state, a);
      if (aState) {
        if (aState.p) {
          throw aState.p;
        }
        return aState.v;
      }
      if (hasInitialValue(a)) {
        return a.init;
      }
      throw new Error("no atom init");
    });
    if (promiseOrValue instanceof Promise) {
      promise = promiseOrValue.then((value2) => {
        setAtomValue(state, atom, value2, dependencies, promise);
        flushPending(state);
      }).catch((e) => {
        if (e instanceof Promise) {
          scheduleReadAtomState(state, atom, e);
          return e;
        }
        setAtomReadError(state, atom, e instanceof Error ? e : new Error(e), dependencies, promise);
        flushPending(state);
      });
    } else {
      value = promiseOrValue;
    }
  } catch (errorOrPromise) {
    if (errorOrPromise instanceof Promise) {
      promise = errorOrPromise;
    } else if (errorOrPromise instanceof Error) {
      error = errorOrPromise;
    } else {
      error = new Error(errorOrPromise);
    }
  }
  if (error) {
    setAtomReadError(state, atom, error, dependencies);
  } else if (promise) {
    setAtomReadPromise(state, atom, promise, dependencies);
  } else {
    setAtomValue(state, atom, value, dependencies);
  }
  return getAtomState(state, atom);
};
const readAtom = (state, readingAtom) => {
  const atomState = readAtomState(state, readingAtom);
  return atomState;
};
const addAtom = (state, addingAtom) => {
  let mounted = state.m.get(addingAtom);
  if (!mounted) {
    mounted = mountAtom(state, addingAtom);
  }
  flushPending(state);
  return mounted;
};
const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.d.size || mounted.d.size === 1 && mounted.d.has(atom));
const delAtom = (state, deletingAtom) => {
  const mounted = state.m.get(deletingAtom);
  if (mounted && canUnmountAtom(deletingAtom, mounted)) {
    unmountAtom(state, deletingAtom);
  }
  flushPending(state);
};
const invalidateDependents = (state, atom) => {
  const mounted = state.m.get(atom);
  mounted == null ? void 0 : mounted.d.forEach((dependent) => {
    if (dependent === atom) {
      return;
    }
    setAtomInvalidated(state, dependent);
    invalidateDependents(state, dependent);
  });
};
const writeAtomState = (state, atom, update) => {
  var _a;
  const writePromise = (_a = getAtomState(state, atom)) == null ? void 0 : _a.w;
  if (writePromise) {
    writePromise.then(() => {
      writeAtomState(state, atom, update);
      flushPending(state);
    });
    return;
  }
  const promiseOrVoid = atom.write((a) => {
    const aState = readAtomState(state, a);
    if (aState.e) {
      throw aState.e;
    }
    if (aState.p) {
      if (typeof process === "object" && process.env.NODE_ENV !== "production") {
        console.warn("Reading pending atom state in write operation. We throw a promise for now.", a);
      }
      throw aState.p;
    }
    if ("v" in aState) {
      return aState.v;
    }
    if (typeof process === "object" && process.env.NODE_ENV !== "production") {
      console.warn("[Bug] no value found while reading atom in write operation. This is probably a bug.", a);
    }
    throw new Error("no value found");
  }, (a, v) => {
    if (a === atom) {
      if (!hasInitialValue(a)) {
        throw new Error("no atom init");
      }
      if (v instanceof Promise) {
        const promise = v.then((resolvedValue) => {
          setAtomValue(state, a, resolvedValue);
          invalidateDependents(state, a);
          flushPending(state);
        }).catch((e) => {
          setAtomReadError(state, atom, e instanceof Error ? e : new Error(e));
          flushPending(state);
        });
        setAtomReadPromise(state, atom, promise);
      } else {
        setAtomValue(state, a, v);
      }
      invalidateDependents(state, a);
    } else {
      writeAtomState(state, a, v);
    }
    flushPending(state);
  }, update);
  if (promiseOrVoid instanceof Promise) {
    const promise = promiseOrVoid.finally(() => {
      setAtomWritePromise(state, atom);
      flushPending(state);
    });
    setAtomWritePromise(state, atom, promise);
  }
};
const writeAtom = (state, writingAtom, update) => {
  writeAtomState(state, writingAtom, update);
  flushPending(state);
};
const isActuallyWritableAtom = (atom) => !!atom.write;
const mountAtom = (state, atom, initialDependent) => {
  const atomState = readAtomState(state, atom);
  atomState.d.forEach((_, a) => {
    if (a !== atom) {
      const aMounted = state.m.get(a);
      if (aMounted) {
        aMounted.d.add(atom);
      } else {
        mountAtom(state, a, atom);
      }
    }
  });
  const mounted = {
    d: new Set(initialDependent && [initialDependent]),
    l: new Set(),
    u: void 0
  };
  state.m.set(atom, mounted);
  if (isActuallyWritableAtom(atom) && atom.onMount) {
    const setAtom = (update) => writeAtom(state, atom, update);
    mounted.u = atom.onMount(setAtom);
  }
  return mounted;
};
const unmountAtom = (state, atom) => {
  var _a;
  const onUnmount = (_a = state.m.get(atom)) == null ? void 0 : _a.u;
  if (onUnmount) {
    onUnmount();
  }
  state.m.delete(atom);
  const atomState = getAtomState(state, atom);
  if (atomState) {
    atomState.d.forEach((_, a) => {
      if (a !== atom) {
        const mounted = state.m.get(a);
        if (mounted) {
          mounted.d.delete(atom);
          if (canUnmountAtom(a, mounted)) {
            unmountAtom(state, a);
          }
        }
      }
    });
  } else if (typeof process === "object" && process.env.NODE_ENV !== "production") {
    console.warn("[Bug] could not find atom state to unmount", atom);
  }
};
const mountDependencies = (state, atom, atomState, prevDependencies) => {
  const dependencies = new Set(atomState.d.keys());
  prevDependencies.forEach((_, a) => {
    if (dependencies.has(a)) {
      dependencies.delete(a);
      return;
    }
    const mounted = state.m.get(a);
    if (mounted) {
      mounted.d.delete(atom);
      if (canUnmountAtom(a, mounted)) {
        unmountAtom(state, a);
      }
    }
  });
  dependencies.forEach((a) => {
    const mounted = state.m.get(a);
    if (mounted) {
      const dependents = mounted.d;
      dependents.add(atom);
    } else {
      mountAtom(state, a, atom);
    }
  });
};
const commitAtomState = (state, atom, atomState, prevDependencies) => {
  if (typeof process === "object" && process.env.NODE_ENV !== "production") {
    Object.freeze(atomState);
  }
  const isNewAtom = !state.a.has(atom);
  state.a.set(atom, atomState);
  if (state.l) {
    state.l(atom, isNewAtom);
  }
  ++state.v;
  if (!state.p.has(atom)) {
    state.p.set(atom, prevDependencies);
  }
};
const flushPending = (state) => {
  const pending = Array.from(state.p);
  state.p.clear();
  pending.forEach(([atom, prevDependencies]) => {
    const atomState = getAtomState(state, atom);
    if (atomState) {
      if (prevDependencies) {
        mountDependencies(state, atom, atomState, prevDependencies);
      }
    } else if (typeof process === "object" && process.env.NODE_ENV !== "production") {
      console.warn("[Bug] atom state not found in flush", atom);
    }
    const mounted = state.m.get(atom);
    mounted == null ? void 0 : mounted.l.forEach((listener) => listener());
  });
};
const subscribeAtom = (state, atom, callback) => {
  const mounted = addAtom(state, atom);
  const listeners = mounted.l;
  listeners.add(callback);
  return () => {
    listeners.delete(callback);
    delAtom(state, atom);
  };
};
const restoreAtoms = (state, values) => {
  for (const [atom, value] of values) {
    if (hasInitialValue(atom)) {
      setAtomValue(state, atom, value);
      invalidateDependents(state, atom);
    }
  }
  flushPending(state);
};

const TARGET = Symbol();
const GET_VERSION = Symbol();
const createMutableSource = (target, getVersion) => ({
  [TARGET]: target,
  [GET_VERSION]: getVersion
});
const useMutableSource = (source, getSnapshot, subscribe) => {
  const lastVersion = useRef(0);
  const currentVersion = source[GET_VERSION](source[TARGET]);
  const [state, setState] = useState(() => [
    source,
    getSnapshot,
    subscribe,
    currentVersion,
    getSnapshot(source[TARGET])
  ]);
  let currentSnapshot = state[4];
  if (state[0] !== source || state[1] !== getSnapshot || state[2] !== subscribe) {
    currentSnapshot = getSnapshot(source[TARGET]);
    setState([
      source,
      getSnapshot,
      subscribe,
      currentVersion,
      currentSnapshot
    ]);
  } else if (currentVersion !== state[3] && currentVersion !== lastVersion.current) {
    currentSnapshot = getSnapshot(source[TARGET]);
    if (!Object.is(currentSnapshot, state[4])) {
      setState([
        source,
        getSnapshot,
        subscribe,
        currentVersion,
        currentSnapshot
      ]);
    }
  }
  useEffect(() => {
    let didUnsubscribe = false;
    const checkForUpdates = () => {
      if (didUnsubscribe) {
        return;
      }
      try {
        const nextSnapshot = getSnapshot(source[TARGET]);
        const nextVersion = source[GET_VERSION](source[TARGET]);
        lastVersion.current = nextVersion;
        setState((prev) => {
          if (prev[0] !== source || prev[1] !== getSnapshot || prev[2] !== subscribe) {
            return prev;
          }
          if (Object.is(prev[4], nextSnapshot)) {
            return prev;
          }
          return [
            prev[0],
            prev[1],
            prev[2],
            nextVersion,
            nextSnapshot
          ];
        });
      } catch (e) {
        setState((prev) => [...prev]);
      }
    };
    const unsubscribe = subscribe(source[TARGET], checkForUpdates);
    checkForUpdates();
    return () => {
      didUnsubscribe = true;
      unsubscribe();
    };
  }, [source, getSnapshot, subscribe]);
  return currentSnapshot;
};

const createStoreForProduction = (initialValues) => {
  const state = createState(initialValues);
  const stateMutableSource = createMutableSource(state, () => state.v);
  const commitCallback = () => flushPending(state);
  const updateAtom = (atom, update) => writeAtom(state, atom, update);
  return [stateMutableSource, updateAtom, commitCallback];
};
const createStoreForDevelopment = (initialValues) => {
  const stateListener = (updatedAtom, isNewAtom) => {
    ++debugStore.version;
    if (isNewAtom) {
      debugStore.atoms = [...debugStore.atoms, updatedAtom];
    }
    Promise.resolve().then(() => {
      debugStore.listeners.forEach((listener) => listener());
    });
  };
  const state = createState(initialValues, stateListener);
  const stateMutableSource = createMutableSource(state, () => state.v);
  const commitCallback = () => flushPending(state);
  const updateAtom = (atom, update) => writeAtom(state, atom, update);
  const debugStore = {
    version: 0,
    atoms: [],
    state,
    listeners: new Set()
  };
  const debugMutableSource = createMutableSource(debugStore, () => debugStore.version);
  const restore = (values) => restoreAtoms(state, values);
  return [
    stateMutableSource,
    updateAtom,
    commitCallback,
    debugMutableSource,
    restore
  ];
};
const createStore = typeof process === "object" && process.env.NODE_ENV !== "production" ? createStoreForDevelopment : createStoreForProduction;
const StoreContextMap = new Map();
const getStoreContext = (scope) => {
  if (!StoreContextMap.has(scope)) {
    StoreContextMap.set(scope, createContext(createStore()));
  }
  return StoreContextMap.get(scope);
};
const isDevStore = (store) => {
  return store.length > 3;
};

const Provider = ({ initialValues, scope, children }) => {
  const storeRef = useRef(null);
  if (storeRef.current === null) {
    storeRef.current = createStore(initialValues);
  }
  if (typeof process === "object" && process.env.NODE_ENV !== "production" && isDevStore(storeRef.current)) {
    useDebugState(storeRef.current);
  }
  const StoreContext = getStoreContext(scope);
  return createElement(StoreContext.Provider, { value: storeRef.current }, children);
};
const atomToPrintable = (atom) => atom.debugLabel || atom.toString();
const stateToPrintable = ([state, atoms]) => Object.fromEntries(atoms.flatMap((atom) => {
  const mounted = state.m.get(atom);
  if (!mounted) {
    return [];
  }
  const dependents = mounted.d;
  const atomState = state.a.get(atom) || {};
  return [
    [
      atomToPrintable(atom),
      {
        value: atomState.e || atomState.p || atomState.w || atomState.v,
        dependents: Array.from(dependents).map(atomToPrintable)
      }
    ]
  ];
}));
const getDebugStateAndAtoms = ({
  atoms,
  state
}) => [state, atoms];
const subscribeDebugStore = ({ listeners }, callback) => {
  listeners.add(callback);
  return () => listeners.delete(callback);
};
const useDebugState = (store) => {
  const debugMutableSource = store[3];
  const [state, atoms] = useMutableSource(debugMutableSource, getDebugStateAndAtoms, subscribeDebugStore);
  useDebugValue([state, atoms], stateToPrintable);
};

let keyCount = 0;
function atom(read, write) {
  const key = `atom${++keyCount}`;
  const config = {
    toString: () => key
  };
  if (typeof read === "function") {
    config.read = read;
  } else {
    config.init = read;
    config.read = (get) => get(config);
    config.write = (get, set, update) => {
      set(config, typeof update === "function" ? update(get(config)) : update);
    };
  }
  if (write) {
    config.write = write;
  }
  return config;
}

const isWritable = (atom) => !!atom.write;
function useAtom(atom) {
  const getAtomValue = useCallback((state) => {
    const atomState = readAtom(state, atom);
    if (atomState.e) {
      throw atomState.e;
    }
    if (atomState.p) {
      throw atomState.p;
    }
    if (atomState.w) {
      throw atomState.w;
    }
    if ("v" in atomState) {
      return atomState.v;
    }
    throw new Error("no atom value");
  }, [atom]);
  const subscribe = useCallback((state, callback) => subscribeAtom(state, atom, callback), [atom]);
  const StoreContext = getStoreContext(atom.scope);
  const [mutableSource, updateAtom, commitCallback] = useContext(StoreContext);
  const value = useMutableSource(mutableSource, getAtomValue, subscribe);
  useEffect(() => {
    commitCallback();
  });
  const setAtom = useCallback((update) => {
    if (isWritable(atom)) {
      updateAtom(atom, update);
    } else {
      throw new Error("not writable atom");
    }
  }, [updateAtom, atom]);
  useDebugValue(value);
  return [value, setAtom];
}

export { Provider, getStoreContext as SECRET_INTERNAL_getStoreContext, useMutableSource as SECRET_INTERNAL_useMutableSource, atom, useAtom };
