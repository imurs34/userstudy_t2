import { useContext, useCallback, useMemo } from 'react';
import { SECRET_INTERNAL_getStoreContext, useAtom, atom } from 'jotai';

function useUpdateAtom(anAtom) {
  const StoreContext = SECRET_INTERNAL_getStoreContext(anAtom.scope);
  const [, updateAtom] = useContext(StoreContext);
  const setAtom = useCallback((update) => updateAtom(anAtom, update), [updateAtom, anAtom]);
  return setAtom;
}

function useAtomValue(anAtom) {
  return useAtom(anAtom)[0];
}

const RESET = Symbol();
function atomWithReset(initialValue) {
  const anAtom = atom(initialValue, (get, set, update) => {
    if (update === RESET) {
      set(anAtom, initialValue);
    } else {
      set(anAtom, typeof update === "function" ? update(get(anAtom)) : update);
    }
  });
  return anAtom;
}

function useResetAtom(anAtom) {
  const StoreContext = SECRET_INTERNAL_getStoreContext(anAtom.scope);
  const [, updateAtom] = useContext(StoreContext);
  const setAtom = useCallback(() => updateAtom(anAtom, RESET), [updateAtom, anAtom]);
  return setAtom;
}

function useReducerAtom(anAtom, reducer) {
  const [state, setState] = useAtom(anAtom);
  const dispatch = useCallback((action) => {
    setState((prev) => reducer(prev, action));
  }, [setState, reducer]);
  return [state, dispatch];
}

function atomWithReducer(initialValue, reducer) {
  const anAtom = atom(initialValue, (get, set, action) => set(anAtom, reducer(get(anAtom), action)));
  return anAtom;
}

function atomFamily(initializeAtom, areEqual) {
  let shouldRemove = null;
  const atoms = new Map();
  const createAtom = (param) => {
    let item;
    if (areEqual === void 0) {
      item = atoms.get(param);
    } else {
      for (let [key, value] of atoms) {
        if (areEqual(key, param)) {
          item = value;
          break;
        }
      }
    }
    if (item !== void 0) {
      if (shouldRemove == null ? void 0 : shouldRemove(item[1], param)) {
        atoms.delete(param);
      } else {
        return item[0];
      }
    }
    const newAtom = initializeAtom(param);
    atoms.set(param, [newAtom, Date.now()]);
    return newAtom;
  };
  createAtom.remove = (param) => {
    if (areEqual === void 0) {
      atoms.delete(param);
    } else {
      for (let [key] of atoms) {
        if (areEqual(key, param)) {
          atoms.delete(key);
          break;
        }
      }
    }
  };
  createAtom.setShouldRemove = (fn) => {
    shouldRemove = fn;
    if (!shouldRemove)
      return;
    for (let [key, value] of atoms) {
      if (shouldRemove(value[1], key)) {
        atoms.delete(key);
      }
    }
  };
  return createAtom;
}

const getWeakCacheItem = (cache, deps) => {
  const [dep, ...rest] = deps;
  const entry = cache.get(dep);
  if (!entry) {
    return;
  }
  if (!rest.length) {
    return entry[1];
  }
  return getWeakCacheItem(entry[0], rest);
};
const setWeakCacheItem = (cache, deps, item) => {
  const [dep, ...rest] = deps;
  let entry = cache.get(dep);
  if (!entry) {
    entry = [new WeakMap()];
    cache.set(dep, entry);
  }
  if (!rest.length) {
    entry[1] = item;
    return;
  }
  setWeakCacheItem(entry[0], rest, item);
};

const selectAtomCache = new WeakMap();
function selectAtom(anAtom, selector, equalityFn = Object.is) {
  const deps = [anAtom, selector, equalityFn];
  const cachedAtom = getWeakCacheItem(selectAtomCache, deps);
  if (cachedAtom) {
    return cachedAtom;
  }
  let initialized = false;
  let prevSlice;
  const derivedAtom = atom((get) => {
    const slice = selector(get(anAtom));
    if (initialized && equalityFn(prevSlice, slice)) {
      return prevSlice;
    }
    initialized = true;
    prevSlice = slice;
    return slice;
  });
  derivedAtom.scope = anAtom.scope;
  setWeakCacheItem(selectAtomCache, deps, derivedAtom);
  return derivedAtom;
}

function useAtomCallback(callback, scope) {
  const anAtom = useMemo(() => atom(null, (get, set, [arg, resolve, reject]) => {
    try {
      resolve(callback(get, set, arg));
    } catch (e) {
      reject(e);
    }
  }), [callback]);
  anAtom.scope = scope;
  const [, invoke] = useAtom(anAtom);
  return useCallback((arg) => new Promise((resolve, reject) => {
    invoke([arg, resolve, reject]);
  }), [invoke]);
}

const freezeAtomCache = new WeakMap();
const deepFreeze = (obj) => {
  if (typeof obj !== "object" || obj === null)
    return;
  Object.freeze(obj);
  const propNames = Object.getOwnPropertyNames(obj);
  for (const name of propNames) {
    const value = obj[name];
    deepFreeze(value);
  }
  return obj;
};
function freezeAtom(anAtom) {
  const deps = [anAtom];
  const cachedAtom = getWeakCacheItem(freezeAtomCache, deps);
  if (cachedAtom) {
    return cachedAtom;
  }
  const frozenAtom = atom((get) => deepFreeze(get(anAtom)), (_get, set, arg) => set(anAtom, arg));
  frozenAtom.scope = anAtom.scope;
  setWeakCacheItem(freezeAtomCache, deps, frozenAtom);
  return frozenAtom;
}
function freezeAtomCreator(createAtom) {
  return (...params) => {
    const anAtom = createAtom(...params);
    const origRead = anAtom.read;
    anAtom.read = (get) => deepFreeze(origRead(get));
    return anAtom;
  };
}

const splitAtomCache = new WeakMap();
const isWritable = (atom2) => !!atom2.write;
const isFunction = (x) => typeof x === "function";
function splitAtom(arrAtom, keyExtractor) {
  const deps = keyExtractor ? [arrAtom, keyExtractor] : [arrAtom];
  const cachedAtom = getWeakCacheItem(splitAtomCache, deps);
  if (cachedAtom) {
    return cachedAtom;
  }
  let currentAtomList;
  let currentKeyList;
  const keyToAtom = (key) => {
    const index = currentKeyList == null ? void 0 : currentKeyList.indexOf(key);
    if (index === void 0 || index === -1) {
      return void 0;
    }
    return currentAtomList == null ? void 0 : currentAtomList[index];
  };
  const read = (get) => {
    let nextAtomList = [];
    let nextKeyList = [];
    get(arrAtom).forEach((item, index) => {
      const key = keyExtractor ? keyExtractor(item) : index;
      nextKeyList[index] = key;
      const cachedAtom2 = keyToAtom(key);
      if (cachedAtom2) {
        nextAtomList[index] = cachedAtom2;
        return;
      }
      const read2 = (get2) => {
        const index2 = currentKeyList == null ? void 0 : currentKeyList.indexOf(key);
        if (index2 === void 0 || index2 === -1) {
          throw new Error("index not found");
        }
        return get2(arrAtom)[index2];
      };
      const write2 = (get2, set, update) => {
        const index2 = currentKeyList == null ? void 0 : currentKeyList.indexOf(key);
        if (index2 === void 0 || index2 === -1) {
          throw new Error("index not found");
        }
        const prev = get2(arrAtom);
        const nextItem = isFunction(update) ? update(prev[index2]) : update;
        set(arrAtom, [
          ...prev.slice(0, index2),
          nextItem,
          ...prev.slice(index2 + 1)
        ]);
      };
      const itemAtom = isWritable(arrAtom) ? atom(read2, write2) : atom(read2);
      itemAtom.scope = arrAtom.scope;
      nextAtomList[index] = itemAtom;
    });
    currentKeyList = nextKeyList;
    if (currentAtomList && currentAtomList.length === nextAtomList.length && currentAtomList.every((x, i) => x === nextAtomList[i])) {
      return currentAtomList;
    }
    return currentAtomList = nextAtomList;
  };
  const write = (get, set, atomToRemove) => {
    const index = get(splittedAtom).indexOf(atomToRemove);
    if (index >= 0) {
      const prev = get(arrAtom);
      set(arrAtom, [
        ...prev.slice(0, index),
        ...prev.slice(index + 1)
      ]);
    }
  };
  const splittedAtom = isWritable(arrAtom) ? atom(read, write) : atom(read);
  splittedAtom.scope = arrAtom.scope;
  setWeakCacheItem(splitAtomCache, deps, splittedAtom);
  return splittedAtom;
}

function atomWithDefault(getDefault) {
  const EMPTY = Symbol();
  const overwrittenAtom = atom(EMPTY);
  const anAtom = atom((get) => {
    const overwritten = get(overwrittenAtom);
    if (overwritten !== EMPTY) {
      return overwritten;
    }
    return getDefault(get);
  }, (get, set, update) => set(overwrittenAtom, typeof update === "function" ? update(get(anAtom)) : update));
  return anAtom;
}

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
const waitForAllCache = new WeakMap();
function waitForAll(atoms) {
  const cachedAtom = Array.isArray(atoms) && getWeakCacheItem(waitForAllCache, atoms);
  if (cachedAtom) {
    return cachedAtom;
  }
  const unwrappedAtoms = unwrapAtoms(atoms);
  const derivedAtom = atom((get) => {
    const promises = [];
    const values = unwrappedAtoms.map((anAtom, index) => {
      try {
        return get(anAtom);
      } catch (e) {
        if (e instanceof Promise) {
          promises[index] = e;
        } else {
          throw e;
        }
      }
    });
    if (promises.length) {
      throw Promise.all(promises);
    }
    return wrapResults(atoms, values);
  });
  const waitForAllScope = unwrappedAtoms[0].scope;
  derivedAtom.scope = waitForAllScope;
  validateAtomScopes(waitForAllScope, unwrappedAtoms);
  if (Array.isArray(atoms)) {
    setWeakCacheItem(waitForAllCache, atoms, derivedAtom);
  }
  return derivedAtom;
}
const unwrapAtoms = (atoms) => Array.isArray(atoms) ? atoms : Object.getOwnPropertyNames(atoms).map((key) => atoms[key]);
const wrapResults = (atoms, results) => Array.isArray(atoms) ? results : Object.getOwnPropertyNames(atoms).reduce((out, key, idx) => __spreadProps(__spreadValues({}, out), { [key]: results[idx] }), {});
function validateAtomScopes(scope, atoms) {
  if (scope && !atoms.every((a) => a.scope === scope)) {
    console.warn("Different scopes were found for atoms supplied to waitForAll. This is unsupported and will result in unexpected behavior.");
  }
}

function atomWithHash(key, initialValue, serialize = JSON.stringify, deserialize = JSON.parse) {
  const anAtom = atom(initialValue, (get, set, update) => {
    const newValue = typeof update === "function" ? update(get(anAtom)) : update;
    set(anAtom, newValue);
    const searchParams = new URLSearchParams(location.hash.slice(1));
    searchParams.set(key, serialize(newValue));
    location.hash = searchParams.toString();
  });
  anAtom.onMount = (setAtom) => {
    const callback = () => {
      const searchParams = new URLSearchParams(location.hash.slice(1));
      const str = searchParams.get(key);
      if (str !== null) {
        setAtom(deserialize(str));
      }
    };
    window.addEventListener("hashchange", callback);
    callback();
    return () => {
      window.removeEventListener("hashchange", callback);
    };
  };
  return anAtom;
}

const defaultStorage = {
  getItem: (key) => {
    const storedValue = localStorage.getItem(key);
    if (storedValue === null) {
      throw new Error("no value stored");
    }
    return JSON.parse(storedValue);
  },
  setItem: (key, newValue) => {
    localStorage.setItem(key, JSON.stringify(newValue));
  }
};
function atomWithStorage(key, initialValue, storage = defaultStorage) {
  const getInitialValue = () => {
    try {
      return storage.getItem(key);
    } catch {
      return initialValue;
    }
  };
  const baseAtom = atom(initialValue);
  baseAtom.onMount = (setAtom) => {
    const value = getInitialValue();
    if (value instanceof Promise) {
      value.then(setAtom);
    } else {
      setAtom(value);
    }
  };
  const anAtom = atom((get) => get(baseAtom), (get, set, update) => {
    const newValue = typeof update === "function" ? update(get(baseAtom)) : update;
    set(baseAtom, newValue);
    storage.setItem(key, newValue);
  });
  return anAtom;
}

export { RESET, atomFamily, atomWithDefault, atomWithHash, atomWithReducer, atomWithReset, atomWithStorage, freezeAtom, freezeAtomCreator, selectAtom, splitAtom, useAtomCallback, useAtomValue, useReducerAtom, useResetAtom, useUpdateAtom, waitForAll };
